using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace GSN.Skill.Games.Common.Utils
{
	/// Extension methods to bridge between autogenerated ActionScript code and C#
	public static class StringExtensions
	{

		public static string ToColor(this string str, string color) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return color + str + "</color>";
		}

		// pass 0xff00ff or some such int. 
		public static string ToColor(this string str, int color) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return "<color=#" + color.ToString("X3") + "ff>" + str + "</color>";
		}

		public static string ToRed(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_RED + str + "</color>";
		}

		public static string ToGreen(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_GREEN + str + "</color>";
		}

		public static string ToBlue(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_BLUE + str + "</color>";
		}

		public static string ToYellow(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_YELLOW + str + "</color>";
		}

		public static string ToCyan(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_CYAN + str + "</color>";
		}

		public static string ToMagenta(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_MAGENTA + str + "</color>";
		}

		public static string ToOrange(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_ORANGE + str + "</color>";
		}

		public static string ToSpringGreen(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_SPRING_GREEN + str + "</color>";
		}

		public static string ToViolet(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_VIOLET + str + "</color>";
		}

		public static string ToCanary(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_CANARY + str + "</color>";
		}

		public static string ToRoyalBlue(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_ROYAL_BLUE + str + "</color>";
		}

		public static string ToPink(this string str) 
		{
			#if (DEBUG == false)
				return str;
			#endif
			return GsnDebug.COLOR_PINK + str + "</color>";
		}

		public static string CharAt(this string str, int index)
		{
			return str[index].ToString();
		}


		public static int CharCodeAt(this string str, int index)
		{
			return (int)str[index];
		}

		public static string Substring(this string str, int startIndex, int endindex = 0x7fffffff)
		{
			if (endindex == 0x7fffffff)
				endindex = str.Length;
			int length = endindex - startIndex;
			return str.Substring(startIndex, length);
		}

		public static string Substr(this string str, int index, int length = 0x7fffffff)
		{
			if (length == 0x7fffffff)
				length = str.Length - 1;
			return str.Substring(index, length);
		}

		public static GsnVector<string> Split(this string str, string delim)
		{
			if (str == null)
				return null;

			string[] strs = str.Split(delim[0]);

			GsnVector<string> v = new GsnVector<string>();
			for (int i = 0; i < strs.Length; ++i)
			{
				v.Add(strs.GetValue(i).ToString());
			}

			return v;
		}

		public static GsnVector<int> SplitToInts(this string str, string delim)
		{
			if (str == null || str == "")
				return null;

			string[] strs = str.Split(delim[0]);

			GsnVector<int> v = new GsnVector<int>();
			for (int i = 0; i < strs.Length; ++i)
			{
				v.Add(Convert.ToInt32(strs[i]));
			}
			return v;
		}

		public static string StripCarriageReturn(this string str)
		{
			const string findCarriageReturnRegExp = "\r";
			return Regex.Replace(str, findCarriageReturnRegExp, "");
		}

		public static string TimeFormatMSFromSeconds(int totalSeconds)
		{
			int minutes = totalSeconds / 60;
			int seconds = totalSeconds % 60;

			//Force seconds to have a leading 0 if <10
			return String.Format("{0}:{1:00}", minutes, seconds);
		}

		public static string GetHexString(byte [] input) 
		{
			// Convert the hash to a string
			// Create a new Stringbuilder to collect the bytes and create a string.
			StringBuilder sBuilder = new StringBuilder();

			// Loop through each byte of the hashed data and format each one as a hexadecimal string. 
			for (int i = 0; i < input.Length; i++)
			{
				sBuilder.Append(input[i].ToString("X2"));
			}

			// Return the hexadecimal string. 
			return sBuilder.ToString();
		}

		public static byte[] HexToBytes(this string input) 
		{
			return Enumerable.Range(0, input.Length / 2).Select(x => Convert.ToByte(input.Substring(x * 2, 2), 16)).ToArray();
		}

		/// <summary>
		/// Numbers within strings are compared using numeric value, that is, Name2.txt < Name7.txt < Name25.txt.
		/// Numeric comparison only applies to the numerals in the string, not other characters that would have meaning in a true number such as a negative sign or a decimal point.
		/// This function is useful for comparing version strings. Because version string is more than one number, so we can't simply parse floats and compare. 
		/// Also String.Compare will return 7 > 10, so we can't use simple strings comparison. There is Version class in System namespace, but it doesn’t support version with more 
		/// than 4 components and also doesn't support letters in version string (1.0a). 
		/// This function inspired by NSNumericSearch option for Objective-C NSString class, which is recommended way of version comparison in Objective-C world.
		/// </summary>
		/// <returns>Less than zero if s1 precedes s2 in the sort order. Zero if s1 occurs in the same position as s2 in the sort order. Greater than zero if s1 follows s2 in the sort order.</returns>
		public static int CompareWithNumericSearch(this string s1, string s2, bool ignoreCase = false)
		{
			//check special cases
			if (s1 == null && s2 == null)
			{
				return 0;
			}
			else if (s1 == null)
			{
				return -1;
			}
			else if (s2 == null)
			{
				return 1;
			}
			else if (s1.Length == 0 && s2.Length == 0)
			{
				return 0;
			}
			else if (s1.Length == 0)
			{
				return -1;
			}
			else if (s2.Length == 0)
			{
				return 1;
			}

			//split strings to digits/not-digits segments
			string [] s1Strings = Regex.Split(s1, @"\d+").Where(s => s != String.Empty).ToArray();
			string [] s2Strings = Regex.Split(s2, @"\d+").Where(s => s != String.Empty).ToArray();
			string [] s1Numbers = Regex.Split(s1, @"\D+").Where(s => s != String.Empty).ToArray();
			string [] s2Numbers = Regex.Split(s2, @"\D+").Where(s => s != String.Empty).ToArray();

			uint currentSubstring = 0;
			bool currentIsDigit   = Char.IsDigit(s1, 0);

			//check that both strings starts with digit or not-digit
			if (Char.IsDigit(s2, 0) != currentIsDigit)
			{
				return currentIsDigit ? -1 : 1;
			}

			int s1SubstringsCount = s1Strings.Length + s1Numbers.Length;
			int s2SubstringsCount = s2Strings.Length + s2Numbers.Length;

			for (int minSubstringsCount = Math.Min(s1SubstringsCount, s2SubstringsCount); currentSubstring < minSubstringsCount; currentSubstring++, currentIsDigit = ! currentIsDigit)
			{
				string currentSubstring1, currentSubstring2;

				if (currentIsDigit)
				{
					currentSubstring1 = s1Numbers [currentSubstring / 2];
					currentSubstring2 = s2Numbers [currentSubstring / 2];

					if (currentSubstring1.Length != currentSubstring2.Length)
					{
						return currentSubstring1.Length < currentSubstring2.Length ? -1 : 1;
					}
				}
				else
				{
					currentSubstring1 = s1Strings [currentSubstring / 2];
					currentSubstring2 = s2Strings [currentSubstring / 2];
				}

				int compareResult = String.Compare(currentSubstring1, currentSubstring2, ignoreCase);

				if (compareResult != 0)
				{
					return compareResult;
				}
			}

			if (s1SubstringsCount == s2SubstringsCount)
			{
				return 0;
			}
			else
			{
				return s1SubstringsCount > s2SubstringsCount ? 1 : -1;
			}
		}
	}
}
